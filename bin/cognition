#!/usr/bin/env python3
"""
Cognition Engines CLI
Command-line interface for decision indexing, querying, and guardrail checking
"""

import sys
import json
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))


def cmd_index(args):
    """Index decisions from YAML files."""
    from cognition_engines.accelerators.semantic_index import get_index
    
    if len(args) < 1:
        print("Usage: cognition index <decisions_directory>")
        return 1
    
    decisions_dir = Path(args[0])
    if not decisions_dir.exists():
        print(f"Error: Directory not found: {decisions_dir}")
        return 1
    
    index = get_index()
    
    # Find decision YAML files
    yaml_files = list(decisions_dir.rglob("*.yaml")) + list(decisions_dir.rglob("*.yml"))
    print(f"Found {len(yaml_files)} YAML files")
    
    # Parse and index
    decisions = []
    for path in yaml_files:
        try:
            content = path.read_text()
            data = parse_yaml_simple(content)
            if data and isinstance(data, dict) and ("decision" in data or "title" in data):
                data["_source_file"] = str(path)
                decisions.append(data)
        except Exception as e:
            print(f"Warning: Failed to parse {path}: {e}")
    
    print(f"Parsed {len(decisions)} decisions")
    
    if decisions:
        count = index.index_decisions(decisions)
        print(f"Indexed {count} decisions successfully")
    
    return 0


def parse_yaml_simple(content: str) -> dict:
    """Simple YAML parser for decision files (single document, flat-ish structure)."""
    try:
        import yaml
        return yaml.safe_load(content)
    except ImportError:
        pass
    
    # Basic parsing
    result = {}
    current_key = None
    current_value_lines = []
    in_multiline = False
    
    for line in content.split('\n'):
        # Skip comments
        if line.strip().startswith('#'):
            continue
        
        # Multiline string continuation
        if in_multiline:
            if line.startswith('  ') or line.strip() == '':
                current_value_lines.append(line.strip())
                continue
            else:
                result[current_key] = '\n'.join(current_value_lines)
                in_multiline = False
        
        # Key: value pair
        if ':' in line and not line.startswith(' '):
            key, val = line.split(':', 1)
            key = key.strip()
            val = val.strip()
            
            if val == '|':
                current_key = key
                current_value_lines = []
                in_multiline = True
            elif val:
                # Parse value
                if val.lower() == 'true':
                    result[key] = True
                elif val.lower() == 'false':
                    result[key] = False
                elif val.startswith('"') and val.endswith('"'):
                    result[key] = val[1:-1]
                else:
                    try:
                        result[key] = float(val)
                    except ValueError:
                        result[key] = val
            else:
                result[key] = None
    
    if in_multiline and current_key:
        result[current_key] = '\n'.join(current_value_lines)
    
    return result


def cmd_query(args):
    """Query similar decisions."""
    from cognition_engines.accelerators.semantic_index import get_index
    
    if len(args) < 1:
        print("Usage: cognition query <context> [--category CAT] [--min-confidence N]")
        return 1
    
    # Parse args
    context = args[0]
    category = None
    min_confidence = None
    
    i = 1
    while i < len(args):
        if args[i] == "--category" and i + 1 < len(args):
            category = args[i + 1]
            i += 2
        elif args[i] == "--min-confidence" and i + 1 < len(args):
            min_confidence = float(args[i + 1])
            i += 2
        else:
            i += 1
    
    index = get_index()
    results = index.query(context, n_results=5, category=category, min_confidence=min_confidence)
    
    if not results:
        print("No similar decisions found")
        return 0
    
    print(f"\n{'='*60}")
    print(f"Query: {context}")
    print(f"{'='*60}\n")
    
    for i, r in enumerate(results, 1):
        meta = r.get("metadata", {})
        dist = r.get("distance")
        
        print(f"[{i}] {meta.get('title', 'Untitled')}")
        print(f"    Category: {meta.get('category', 'N/A')}")
        print(f"    Confidence: {meta.get('confidence', 'N/A')}")
        print(f"    Distance: {dist:.4f}" if dist else "    Distance: N/A")
        print(f"    Status: {meta.get('status', 'N/A')}")
        print()
    
    return 0


def cmd_check(args):
    """Check guardrails for a decision context."""
    from cognition_engines.guardrails.engine import get_engine, load_default_guardrails
    
    # Parse args into context dict
    context = {}
    i = 0
    while i < len(args):
        if args[i].startswith("--") and i + 1 < len(args):
            key = args[i][2:].replace("-", "_")
            value = args[i + 1]
            # Try to parse as number or bool
            if value.lower() == "true":
                value = True
            elif value.lower() == "false":
                value = False
            else:
                try:
                    value = float(value)
                except ValueError:
                    pass
            context[key] = value
            i += 2
        else:
            i += 1
    
    if not context:
        print("Usage: cognition check --category CAT --stakes LEVEL --confidence N ...")
        print("\nExample:")
        print("  cognition check --category architecture --stakes high --confidence 0.8")
        return 1
    
    # Load guardrails
    count = load_default_guardrails()
    print(f"Loaded {count} guardrails")
    
    engine = get_engine()
    allowed, results = engine.check(context)
    
    print(f"\n{'='*60}")
    print(f"Context: {json.dumps(context, indent=2)}")
    print(f"{'='*60}\n")
    
    if allowed:
        print("âœ… ALLOWED - All guardrails passed")
    else:
        print("âŒ BLOCKED - Guardrail violation")
    
    print()
    
    for r in results:
        if r.passed:
            print(f"  âœ… {r.guardrail_id}: {r.message}")
        else:
            icon = "ðŸš«" if r.action == "block" else "âš ï¸"
            print(f"  {icon} {r.guardrail_id}: {r.message}")
    
    return 0 if allowed else 1


def cmd_guardrails(args):
    """List loaded guardrails."""
    from cognition_engines.guardrails.engine import get_engine, load_default_guardrails
    
    count = load_default_guardrails()
    engine = get_engine()
    guardrails = engine.list_guardrails()
    
    print(f"Loaded {count} guardrails:\n")
    
    for g in guardrails:
        action_icon = "ðŸš«" if g["action"] == "block" else "âš ï¸" if g["action"] == "warn" else "ðŸ“"
        print(f"{action_icon} {g['id']}")
        print(f"   {g['description']}")
        if g["scope"]:
            print(f"   Scope: {', '.join(g['scope'])}")
        print()
    
    return 0


def cmd_count(args):
    """Count indexed decisions."""
    from cognition_engines.accelerators.semantic_index import get_index
    
    index = get_index()
    count = index.count()
    print(f"Indexed decisions: {count}")
    return 0


def cmd_patterns(args):
    """Run pattern analysis on decisions."""
    from cognition_engines.patterns.detector import PatternDetector
    
    if len(args) < 1:
        print("Usage: cognition patterns <subcommand> [options]")
        print("\nSubcommands:")
        print("  calibration    Confidence calibration report")
        print("  categories     Category success analysis")
        print("  antipatterns   Detect decision anti-patterns")
        print("  full           Full pattern report")
        return 1
    
    subcmd = args[0]
    
    # Parse options
    decisions_dir = "decisions/"
    output_format = "text"
    
    i = 1
    while i < len(args):
        if args[i] in ("--dir", "-d") and i + 1 < len(args):
            decisions_dir = args[i + 1]
            i += 2
        elif args[i] in ("--format", "-f") and i + 1 < len(args):
            output_format = args[i + 1]
            i += 2
        else:
            i += 1
    
    # Load decisions
    detector = PatternDetector()
    count = detector.load_from_directory(Path(decisions_dir))
    
    if count == 0:
        print(f"No decisions found in {decisions_dir}")
        return 1
    
    # Run analysis
    if subcmd == "calibration":
        report = detector.calibration_report()
        if output_format == "json":
            print(json.dumps(report, indent=2))
        else:
            print(f"\n{'='*60}")
            print("Confidence Calibration Report")
            print(f"{'='*60}\n")
            print(f"Total decisions: {report['total_decisions']}")
            print(f"With outcomes: {report['with_outcomes']}")
            print(f"Overall Brier: {report['overall_brier']}")
            print(f"Interpretation: {report['interpretation']}\n")
            
            if report['buckets']:
                print(f"{'Bucket':<12} {'Count':<8} {'Predicted':<10} {'Actual':<10} {'Brier':<8}")
                print("-" * 50)
                for b in report['buckets']:
                    print(f"{b['range']:<12} {b['count']:<8} {b['predicted']:<10.2f} {b['actual']:<10.2f} {b['brier']:<8.4f}")
    
    elif subcmd == "categories":
        report = detector.category_analysis()
        if output_format == "json":
            print(json.dumps(report, indent=2))
        else:
            print(f"\n{'='*60}")
            print("Category Analysis")
            print(f"{'='*60}\n")
            print(f"Total categories: {report['total_categories']}\n")
            
            print(f"{'Category':<20} {'Count':<8} {'Outcomes':<10} {'Confidence':<12} {'Success':<10}")
            print("-" * 60)
            for c in report['categories']:
                print(f"{c['category']:<20} {c['count']:<8} {c['with_outcomes']:<10} {c['avg_confidence']:<12.2f} {c['success_rate']:<10.2f}")
            
            if report['concerning']:
                print(f"\nâš ï¸  Concerning categories:")
                for c in report['concerning']:
                    print(f"  - {c['category']}: {c['reason']}")
    
    elif subcmd == "antipatterns":
        report = detector.detect_antipatterns()
        if output_format == "json":
            print(json.dumps(report, indent=2))
        else:
            print(f"\n{'='*60}")
            print("Anti-Pattern Detection")
            print(f"{'='*60}\n")
            
            if report['total_antipatterns'] == 0:
                print("âœ… No anti-patterns detected")
            else:
                print(f"Found {report['total_antipatterns']} anti-patterns:\n")
                for ap in report['antipatterns']:
                    icon = "ðŸš«" if ap['severity'] == "high" else "âš ï¸" if ap['severity'] == "medium" else "ðŸ“"
                    print(f"{icon} {ap['type']} ({ap['severity']})")
                    print(f"   {ap['description']}")
                    print(f"   Decisions: {', '.join(ap['decisions'][:3])}")
                    print()
    
    elif subcmd == "full":
        report = detector.full_report()
        if output_format == "json":
            print(json.dumps(report, indent=2))
        else:
            print("Full report - use --format json for complete output")
            print(json.dumps(report, indent=2))
    
    else:
        print(f"Unknown subcommand: {subcmd}")
        return 1
    
    return 0


def main():
    if len(sys.argv) < 2:
        print("Cognition Engines CLI")
        print("\nCommands:")
        print("  index <dir>      Index decisions from YAML files")
        print("  query <context>  Query similar decisions")
        print("  check <args>     Check guardrails for decision context")
        print("  guardrails       List loaded guardrails")
        print("  count            Count indexed decisions")
        print("  patterns <sub>   Pattern analysis (calibration, categories, antipatterns)")
        return 1
    
    cmd = sys.argv[1]
    args = sys.argv[2:]
    
    commands = {
        "index": cmd_index,
        "query": cmd_query,
        "check": cmd_check,
        "guardrails": cmd_guardrails,
        "count": cmd_count,
        "patterns": cmd_patterns,
    }
    
    if cmd in commands:
        return commands[cmd](args)
    else:
        print(f"Unknown command: {cmd}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
